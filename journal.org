# -*- mode: org; fill-column: 78; -*-
# Time-stamp: <2023-06-19 18:03:24 krylon>
#
#+TAGS: optimize(o) refactor(r) bug(b) feature(f) architecture(a)
#+TAGS: web(w) database(d) javascript(j) ui(u)
#+TODO: TODO(t) IMPLEMENT(i) TEST(e) RESEARCH(r) | DONE(d)
#+TODO: MEDITATE(m) PLANNING(p) REFINE(n) | FAILED(f) CANCELLED(c) SUSPENDED(s)
#+TODO: EXPERIMENT(x) |
#+PRIORITIES: A G D

* jobq
  jobq is a spooler and queue for batch jobs.
  I will try to keep it simple at first, but I have some ideas for nifty
  features I hope to implement along the way.
** Clocktable
   #+BEGIN: clocktable :scope file :maxlevel 20
   #+CAPTION: Clock summary at [2023-06-19 Mo 18:03]
   | Headline                 | Time   |      |      |      |
   |--------------------------+--------+------+------+------|
   | *Total time*             | *8:07* |      |      |      |
   |--------------------------+--------+------+------+------|
   | jobq                     | 8:07   |      |      |      |
   | \_  Features [0/6]       |        | 0:29 |      |      |
   | \_    Enqueue jobs [0/2] |        |      | 0:09 |      |
   | \_      Scheduling       |        |      |      | 0:09 |
   | \_  Components [0/1]     |        | 7:38 |      |      |
   | \_    Data types [0/2]   |        |      | 7:38 |      |
   | \_      Job              |        |      |      | 5:13 |
   | \_      Queue            |        |      |      | 2:25 |
   #+END:
** Features [0/6]                                                   :feature:
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
   :LOGBOOK:
   CLOCK: [2023-06-18 So 15:40]--[2023-06-18 So 16:00] =>  0:20
   :END:
*** TODO Enqueue jobs [0/2]
    Obviously. When submitted, a job is not executed right away, but added to
    a queue. When ready, the job scheduler/monitor will remove the first one
    from the queue and run it. And then the next one.
**** RESEARCH Scheduling
     :LOGBOOK:
     CLOCK: [2023-06-18 So 16:05]--[2023-06-18 So 16:14] =>  0:09
     :END:
     Would be nice if I could also submit a job and define it should be
     started at a given time.
     Also, I would like to be able to restrict how long a job runs and
     terminate it if it exceeds its time.
     Also, it would be extra nice, if I could state a job should be run not at
     a given time, but in a given time window, e.g. between 20:00 and
     08:00. The scheduler then should juggle the various jobs it should run so
     they all meet their time window.

     [2023-06-18 So 16:06]
     I consulted awesome-go and found a number of job scheduling
     libraries. Most seem to be aimed at cron-like scenarios, but some are
     more flexible/general. I'll look into those.
     Even if I end up not using any of these, I can take some ideas, maybe
     learn a few tricks.
***** quartz https://github.com/reugn/go-quartz
***** cdule https://github.com/deepaksinghvi/cdule
      Uses a database for persistence (optinally sqlite in-memory), which
      sounds nice.
***** tasks https://github.com/madflojo/tasks
      Sounds more like a cron-like scheduler, but I'll put it on my list.
**** MEDITATE [#F] Pipelines
     It would be kind of nice if I could support something equivalent to shell
     pipelines. /Possibly/ even something more complex, like having a sequence
     of commands running as a job instead of a single command.
*** TODO Spool output
    Like ts, my main inspiration, I want to capture the output of running jobs
    and save it to files.
    I also want to, optionally at least, compress the output.
**** Compression
     In the long run, I want to support multiple compression formats, or at
     least do some experimenting/benchmarking with various compression
     algorithms.
     The Go standard library provides support for gzip.
     - https://github.com/klauspost/compress provides a few more
     - https://github.com/ulikunitz/xz provides support for xz, but the README
       says it should not be considered stable.
     To get started, I'll just support gzip initially, because that is part of
     Go's standard library, but I'll implement it in such a way that adding
     support for further compression methods later on becomes as easy as
     possible.
*** TODO Parallel
    I want to be able to - optionally - run multiple jobs in parallel.
*** TODO Multiple queues
    I want to be able to support multiple different queues simultaneously,
    e.g. one queue for downloading files, one for compressing videos, and so
    forth.
** Planning [0/0]                                              :architecture:
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
   [2023-06-19 Mo 17:31]
   My short-term plan is as follows:
   First, I want to get to the point where I can just add jobs and run them.
   My next step would be to add persistence to the queue.
   After that, I would like to round the existing features up by a nice CLI.
** Components [0/1]
   :PROPERTIES:
   :COOKIE_DATA: todo recursive
   :VISIBILITY: children
   :END:
*** Data types [0/2]
    :PROPERTIES:
    :COOKIE_DATA: todo recursive
    :VISIBILITY: children
    :END:
**** TODO Job
     :LOGBOOK:
     CLOCK: [2023-06-18 So 21:35]--[2023-06-18 So 22:40] =>  1:05
     CLOCK: [2023-06-18 So 16:29]--[2023-06-18 So 20:37] =>  4:08
     :END:
     Clearly, I should start here. What properties of a Job do I need. Also,
     how do I run a job, handle output and so forth.

     It would be nice if I could support pipelines, like a shell script. I
     could go cheap and just make it a shell script and then run the shell,
     but ... it doesn't feel right, does it?
**** TODO Queue
     :LOGBOOK:
     CLOCK: [2023-06-19 Mo 17:38]--[2023-06-19 Mo 18:03] =>  0:25
     CLOCK: [2023-06-19 Mo 12:43]--[2023-06-19 Mo 14:43] =>  2:00
     :END:
     I should start thinking about persistence. That would be nice,
     actually. Keep a history, and survive crashes more gracefully.
** Bugs
